/*
 * Project: AI Water Quality Classifier (BLE Final)
 * Board: Seeed Studio Xiao BLE (nRF52840)
 * By: Shriya Sinha
 * * LOGIC FLOW:
 * 1. Continuously reads pH and Turbidity (TDS is OFF to prevent interference).
 * 2. Waits for Button Press.
 * 3. On Press: Turns ON TDS sensor (Pin D7), takes reading, turns OFF.
 * 4. Runs AI Inference.
 * 5. Sends result to Web App via Bluetooth.
 */

#include <AI_Water_Classifier_inferencing.h>  // Edge Impulse Model
#include <Adafruit_TinyUSB.h>                 // For Serial Monitor
#include <bluefruit.h>                        // For bluetooth
#include <Arduino.h>

// --- Pin Connections ---
#define TDS_PIN         A0
#define TURB_PIN        A1
#define PH_PIN          A2
#define BUTTON_PIN      3   
#define TDS_POWER_PIN   7   

// --- ADC Constants ---
const float ADC_REF = 3.3f;   
const int ADC_MAX = 4095;     

// --- Turbidity Constants ---
const float R1 = 2200.0f;     //Voltage Divider
const float R2 = 4700.0f;     
const float DIV_RATIO = R2 / (R1 + R2); 
const float V_CLEAN = 1.160f; // Voltage for clean water
const float V_DIRTY = 0.002f; // Voltage for dirty water
const float TURB_K = 1000.0f / (V_CLEAN - V_DIRTY); 

// --- TDS & pH Constants ---
const float TDS_K_VALUE = 1.0f; 

const float PH_V_NEUTRAL = 1.658f;      
const float PH_SENSITIVITY = 0.0736f;   

// --- BLE Definitions ---
BLEService        waterService = BLEService("19B10000-E8F2-537E-4F6C-D104768A1214");
BLECharacteristic dataChar     = BLECharacteristic("19B10001-E8F2-537E-4F6C-D104768A1214");

// Global variables
float global_avgNtu = 0.0;
float global_avgPh = 0.0;
bool deviceConnected = false;

void setup() {
    Serial.begin(115200);
    analogReadResolution(12);

    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(TDS_POWER_PIN, OUTPUT);
    digitalWrite(TDS_POWER_PIN, LOW); 
    
    // --- BLE SETUP ---
    Bluefruit.begin();
    Bluefruit.setTxPower(4); 
    Bluefruit.setName("WaterAI");
    
    // FIX: Callbacks belong to the Peripheral object
    Bluefruit.Periph.setConnectCallback(connect_callback);
    Bluefruit.Periph.setDisconnectCallback(disconnect_callback);

    // 1. Setup Service
    waterService.begin();

    // 2. Setup Characteristic
    dataChar.setProperties(CHR_PROPS_READ | CHR_PROPS_NOTIFY);
    dataChar.setPermission(SECMODE_OPEN, SECMODE_OPEN);
    dataChar.setFixedLen(128); 
    dataChar.begin();

    // 3. Start Advertising
    Bluefruit.Advertising.addFlags(BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE);
    Bluefruit.Advertising.addTxPower();
    Bluefruit.Advertising.addService(waterService);
    Bluefruit.ScanResponse.addName();
    Bluefruit.Advertising.restartOnDisconnect(true);
    Bluefruit.Advertising.start(0); 

    Serial.println("Bluefruit BLE Active. Waiting for connections...");
}

void connect_callback(uint16_t conn_handle)
{
  BLEConnection* connection = Bluefruit.Connection(conn_handle);
  char central_name[32] = { 0 };
  connection->getPeerName(central_name, sizeof(central_name));
  Serial.print("Connected to ");
  Serial.println(central_name);
  deviceConnected = true;
}

void disconnect_callback(uint16_t conn_handle, uint8_t reason)
{
  (void) conn_handle;
  (void) reason;
  Serial.println("\nDisconnected");
  deviceConnected = false;
}

void loop() {
    // --- PHASE 1: BACKGROUND MONITORING ---
    digitalWrite(TDS_POWER_PIN, LOW); 
    
    int rTurb = analogRead(TURB_PIN);
    int rPh = analogRead(PH_PIN);

    float v_adc = rTurb * (ADC_REF / (float)ADC_MAX);
    float probeV = v_adc / DIV_RATIO;
    float ntu = TURB_K * (V_CLEAN - probeV);
    if (ntu < 0) ntu = 0; if (ntu > 1000) ntu = 1000;
    
    float vPh = rPh * (ADC_REF / (float)ADC_MAX);
    float ph = 7.0 + ((PH_V_NEUTRAL - vPh) / PH_SENSITIVITY);
    
    global_avgNtu = (global_avgNtu * 0.9) + (ntu * 0.1);
    global_avgPh = (global_avgPh * 0.9) + (ph * 0.1);

    // --- PHASE 2: CHECK BUTTON ---
    if (digitalRead(BUTTON_PIN) == LOW) {
        Serial.println(">> Button Pressed! Starting Sequence...");

        // --- PHASE 3: READ TDS ---
        digitalWrite(TDS_POWER_PIN, HIGH); 
        delay(100); 
        
        long tdsSum = 0;
        int samples = 10;
        for(int i=0; i<samples; i++) {
            tdsSum += analogRead(TDS_PIN);
            delay(10);
        }
        digitalWrite(TDS_POWER_PIN, LOW); 
        
        float vTds = (tdsSum / (float)samples) * (ADC_REF / (float)ADC_MAX);
        float avgTds = (133.42 * pow(vTds, 3) - 255.86 * pow(vTds, 2) + 857.39 * vTds) * 0.5 * TDS_K_VALUE;
        if(avgTds < 0) avgTds = 0;

        Serial.print("Inputs -> TDS: "); Serial.print(avgTds);
        Serial.print(" NTU: "); Serial.print(global_avgNtu);
        Serial.print(" pH: "); Serial.println(global_avgPh);

        // --- PHASE 4: RUN AI INFERENCE ---
        float features[EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE];
        features[0] = avgTds;
        features[1] = global_avgNtu;
        features[2] = global_avgPh;

        signal_t signal;
        numpy::signal_from_buffer(features, EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, &signal);
        ei_impulse_result_t result = { 0 };
        run_classifier(&signal, &result, false);

        // --- PHASE 5: GET PREDICTION ---
        int bestIndex = -1;
        float bestScore = 0.0;
        for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
            if (result.classification[ix].value > bestScore) {
                bestScore = result.classification[ix].value;
                bestIndex = ix;
            }
        }

        String prediction = result.classification[bestIndex].label;
        if (bestScore < 0.50) prediction = "Uncertain";

        // --- PHASE 6: SEND TO WEB APP ---
        String json = "{";
        json += "\"lbl\":\"" + prediction + "\",";
        json += "\"conf\":" + String(bestScore, 2) + ",";
        json += "\"tds\":" + String((int)avgTds) + ","; 
        json += "\"turb\":" + String(global_avgNtu, 1) + ","; 
        json += "\"ph\":" + String(global_avgPh, 1);      
        json += "}\n"; // Newline delimiter for framing

        // Send via Bluefruit if connected
        if (deviceConnected) {
            Serial.println("Full JSON: " + json);
            // Manual Chunking to prevent fragmentation issues
            int len = json.length();
            int offset = 0;
            while (offset < len) {
                int chunkSize = min(20, len - offset);
                String chunk = json.substring(offset, offset + chunkSize);
                dataChar.notify(chunk.c_str());
                Serial.println("Sent chunk: " + chunk);
                offset += chunkSize;
                delay(30); 
            }
        } else {
            Serial.println("Device not connected, skipping BLE send.");
            Serial.println("label: ");
            Serial.print(prediction);
        }

        delay(3000); 
        
        while(digitalRead(BUTTON_PIN) == LOW);
        delay(100);
    }
    
    delay(50); 
}
